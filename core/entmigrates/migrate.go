package entmigrates

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"entgo.io/ent/dialect"
	entsql "entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/schema"
	"github.com/dave/jennifer/jen"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/pubgo/funk/assert"
	"github.com/pubgo/funk/config"
	"github.com/pubgo/funk/errors"
	"github.com/pubgo/funk/generic"
	"github.com/pubgo/funk/log"
	"github.com/pubgo/funk/version"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
	"github.com/urfave/cli/v3"
	dp "gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type MigrationWrap struct {
	*Migration
	Executed bool
}

// Migration represents a database migration
type Migration struct {
	Name string

	Description string

	MigrationSql string

	// DataMigrate is a function that will br executed while running this migration.
	DataMigrate MigrateFunc

	// DataRollback will be executed on rollback. Can be nil.
	DataRollback RollbackFunc
}

// GoMigrate represents a collection of all migrations of a database schema.
type GoMigrate struct {
	db         *gorm.DB
	config     *Config
	migrations []*Migration
	tables     []*schema.Table
}

// New returns a new GoMigrate.
func New(db *entsql.Driver, cfg *Config, migrations []*Migration, tables []*schema.Table) *GoMigrate {
	cfg = config.MergeR(generic.Ptr(DefaultConfig), cfg).Unwrap()

	orm := assert.Must1(gorm.Open(dp.New(dp.Config{
		DriverName:           db.Dialect(),
		PreferSimpleProtocol: true,
		Conn:                 db.DB(),
	}), &gorm.Config{
		SkipDefaultTransaction: true,
		NowFunc:                func() time.Time { return time.Now().UTC() },
		Logger: logger.New(log.NewStd(log.GetLogger("gorm").WithCallerSkip(4)), logger.Config{
			SlowThreshold:             200 * time.Millisecond,
			LogLevel:                  logger.Info,
			IgnoreRecordNotFoundError: false,
			Colorful:                  true,
		}),
	}))
	return &GoMigrate{
		db:         orm,
		config:     cfg,
		migrations: migrations,
		tables:     tables,
	}
}

func (g *GoMigrate) Close() error {
	return nil
}

func (g *GoMigrate) Create(tables []*schema.Table) error {
	ctx := context.Background()
	drv := assert.Must1(entsql.Open(dialect.Postgres, exec("15")))
	// apply migrations
	for _, m := range g.migrations {
		if err := drv.Exec(ctx, m.MigrationSql, []any{}, nil); err != nil {
			return err
		}
	}

	var buf bytes.Buffer
	buf.WriteString("-- DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.\n")
	buf.WriteString("-- DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.\n")
	buf.WriteString("-- DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.\n")
	buf.WriteString(fmt.Sprintf("-- driver: %s\n", g.db.Dialector.Name()))
	buf.WriteString("\n")
	var buf1 bytes.Buffer
	atlas := assert.Must1(schema.NewMigrate(
		&schema.WriteDriver{Writer: &buf1, Driver: drv},
		schema.WithDropColumn(true),
		schema.WithDropIndex(true),
		schema.WithForeignKeys(false),
	))
	assert.Must(atlas.Create(context.Background(), tables...))

	if buf1.String() == "" {
		return nil
	} else {
		buf.WriteString(buf1.String())
	}

	now := time.Now()
	name := fmt.Sprintf("sql%d", now.UnixNano())
	filename := fmt.Sprintf("%s.sql", name)
	assert.Must(os.MkdirAll(g.config.MigrationPath, 0o755))
	filename = filepath.Join(g.config.MigrationPath, filename)
	err := os.WriteFile(filename, buf.Bytes(), 0o644)
	if err != nil {
		return err
	}

	mmPkg := "github.com/pubgo/chameleon/internal/components/migrates"
	genFile := jen.NewFile("migrations")
	genFile.HeaderComment("DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.")
	genFile.HeaderComment("DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.")
	genFile.HeaderComment("DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.")
	genFile.Line()
	genFile.Anon("embed")
	genFile.ImportName(mmPkg, "migrates")
	genFile.Commentf("//go:embed %s.sql", name)
	genFile.Var().Id(fmt.Sprintf("%sData string", name))
	genFile.Var().Id("_").Qual(mmPkg, "Migration")
	genFile.Id(fmt.Sprintf(`
func %s() *migrates.Migration {
	return &migrates.Migration{
		Name:         "%s",
		Description:  "%s",
		MigrationSql: %sData,
		DataRollback: nil,
		DataMigrate:  nil,
	}
}
`, name, name, fmt.Sprint(now.String(), " ", version.Version()), name))

	filename = filepath.Join(g.config.MigrationPath, fmt.Sprintf("%s.go", name))
	err = os.WriteFile(filename, []byte(genFile.GoString()), 0o644)
	if err != nil {
		return err
	}
	return nil
}

func (g *GoMigrate) getMigration(name string) *Migration {
	for _, m := range g.migrations {
		if m.Name == name {
			return m
		}
	}
	return nil
}

func (g *GoMigrate) List() ([]*MigrationWrap, error) {
	nameSet, err := g.loadMigrationFromDb(context.Background())
	if err != nil {
		return nil, err
	}

	var mm []*MigrationWrap
	for _, n := range g.migrations {
		mm = append(mm, &MigrationWrap{Migration: n, Executed: nameSet.Contains(n.Name)})
	}
	return mm, nil
}

func (g *GoMigrate) Cmd() *cli.Command {
	return &cli.Command{
		Name:  "migrate",
		Usage: "migrate database schema",
		Commands: []*cli.Command{
			&cli.Command{
				Name:  "migrate",
				Usage: "migrate all migrations",
				Action: func(ctx context.Context, command *cli.Command) error {
					return g.Migrate()
				},
			},
			&cli.Command{
				Name:      "migrate_to",
				Usage:     "migrate_to <name>",
				UsageText: "migrate migrate_to <name>",
				Action: func(ctx context.Context, c *cli.Command) error {
					return g.MigrateTo(c.Args().First())
				},
			},
			&cli.Command{
				Name:  "rollback",
				Usage: "rollback last migration",
				Action: func(ctx context.Context, command *cli.Command) error {
					return g.RollbackLast()
				},
			},
			&cli.Command{
				Name:  "rollback_to",
				Usage: "rollback_to <name>",
				Action: func(ctx context.Context, c *cli.Command) error {
					return g.RollbackTo(c.Args().First())
				},
			},

			&cli.Command{
				Name:  "create",
				Usage: "create migration",
				Action: func(ctx context.Context, command *cli.Command) error {
					return g.Create(g.tables)
				},
			},
			&cli.Command{
				Name:  "list",
				Usage: "list all migrations",
				Action: func(ctx context.Context, command *cli.Command) error {
					for _, m := range assert.Must1(g.List()) {
						fmt.Println("name:", m.Name, "executed:", m.Executed, "description:", m.Description)
					}
					return nil
				},
			},
		},
	}
}

// Migrate executes all migrations that did not run yet.
func (g *GoMigrate) Migrate() error {
	mm, err := g.List()
	if err != nil {
		return err
	}

	for _, m := range mm {
		if m.Executed {
			continue
		}

		err = g.insertMigration(context.Background(), m.Migration)
		if err != nil {
			return err
		}
	}
	return nil
}

func (g *GoMigrate) MigrateTo(name string) error {
	m := g.getMigration(name)
	if m == nil {
		return fmt.Errorf("ormigrate: Tried to migrate to an ID that doesn't exist")
	}

	return g.insertMigration(context.Background(), m)
}

// RollbackLast undo the last migration
func (g *GoMigrate) RollbackLast() error {
	mm, err := g.List()
	if err != nil {
		return err
	}

	for i := len(mm) - 1; i >= 0; i-- {
		if mm[i].Executed {
			continue
		}

		return g.rollbackMigration(context.Background(), mm[i].Migration)
	}

	return nil
}

// RollbackTo undoes migrations up to the given migration that matches the `migrationID`.
// Migration with the matching `name` is not rolled back.
func (g *GoMigrate) RollbackTo(name string) error {
	m := g.getMigration(name)
	if m == nil {
		return fmt.Errorf("ormigrate: Could not find last run migration")
	}
	return g.rollbackMigration(context.Background(), m)
}

// createTableIfNotExists creates a table if it does not already exist in the database.
func (g *GoMigrate) createTableIfNotExists(ctx context.Context) error {
	sql := fmt.Sprintf(sqlTmpl.CreateTable, g.config.TableName, g.config.ColumnName, g.config.ColumnSize)
	err := g.db.WithContext(ctx).Exec(sql).Error
	return err
}

func (g *GoMigrate) tx(ctx context.Context, callback func(tx *gorm.DB) error) error {
	return g.db.WithContext(ctx).Transaction(callback)
}

func (g *GoMigrate) insertMigration(ctx context.Context, m *Migration) error {
	sql := fmt.Sprintf(sqlTmpl.CreateMigration, g.config.TableName, g.config.ColumnName)
	return g.tx(ctx, func(tx *gorm.DB) error {
		err := tx.Exec(m.MigrationSql).Error
		if err != nil {
			return err
		}

		err = tx.Exec(sql, m.Name).Error
		if err != nil {
			return err
		}

		if m.DataMigrate == nil {
			return nil
		}

		return m.DataMigrate(ctx, tx)
	})
}

func (g *GoMigrate) rollbackMigration(ctx context.Context, m *Migration) error {
	sql := fmt.Sprintf(sqlTmpl.DropMigration, g.config.TableName, g.config.ColumnName)
	return g.tx(ctx, func(tx *gorm.DB) error {
		err := tx.Exec(sql, m.Name).Error
		if err != nil {
			return err
		}

		if m.DataRollback == nil {
			return nil
		}

		return m.DataRollback(ctx, tx)
	})
}

func (g *GoMigrate) loadMigrationFromDb(ctx context.Context) (mapset.Set[string], error) {
	err := g.createTableIfNotExists(ctx)
	if err != nil {
		return nil, errors.WrapCaller(err)
	}

	sql := fmt.Sprintf(sqlTmpl.ListMigration, g.config.ColumnName, g.config.TableName)
	var ids []string
	err = g.db.WithContext(ctx).Raw(sql).Pluck(g.config.ColumnName, &ids).Error
	if err != nil {
		return nil, err
	}

	return mapset.NewSet[string](ids...), nil
}

func exec(ver string) string {
	if ver == "" {
		ver = defaultPostgresVersion
	}

	ctx := context.Background()
	waitForLogs := wait.
		ForLog("database system is ready to accept connections").
		WithOccurrence(2).
		WithStartupTimeout(30 * time.Second)

	ctr := assert.Must1(postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:"+ver),
		testcontainers.WithWaitStrategy(waitForLogs),
	))

	return assert.Must1(ctr.ConnectionString(ctx, "sslmode=disable"))
}
