package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"

	"github.com/pubgo/lug/internal/protoutil"
)

const (
	contextPackage = protogen.GoImportPath("context")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
	codesPackage   = protogen.GoImportPath("google.golang.org/grpc/codes")
	statusPackage  = protogen.GoImportPath("google.golang.org/grpc/status")
	grpccPackage   = protogen.GoImportPath("github.com/pubgo/lug/plugins/grpcc")
	xerrorPackage  = protogen.GoImportPath("github.com/pubgo/xerror")
	xgenPackage    = protogen.GoImportPath("github.com/pubgo/lug/xgen")
	reflectPackage = protogen.GoImportPath("reflect")
)

//	"github.com/gofiber/fiber/v2"
//	"github.com/gofiber/fiber/v2/utils"
//	fb "github.com/pubgo/lug/pkg/builder/fiber"
//	"github.com/pubgo/lug/pkg/gutil"
//	"github.com/pubgo/lug/plugins/grpcc"
//	"github.com/pubgo/lug/xgen"
//	"github.com/pubgo/xerror"
//	"google.golang.org/protobuf/types/known/structpb"
//	"google.golang.org/protobuf/types/known/emptypb"
//
//	status "google.golang.org/genproto/googleapis/rpc/status"
//	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
//	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
//	durationpb "google.golang.org/protobuf/types/known/durationpb"
//	emptypb "google.golang.org/protobuf/types/known/emptypb"
//	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
//	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
//	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"

// generateFile generates a _lug.pb.go file containing service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + ".lug.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-lug. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-lug ", version)
	g.P("// - protoc         ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

// generateFileContent generates the service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the grpc package it is being compiled against.")
	g.P("// Requires gRPC-Go v1.32.0 or later.")
	g.P("const _ = ", grpcPackage.Ident("SupportPackageIsVersion7"))
	g.P()
	for _, service := range file.Services {
		genClient(gen, file, g, service)
		genRpcInfo(gen, file, g, service)
	}
}

func genClient(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("func Get", service.GoName, "Client(srv string, opts ...func(cfg *", grpccPackage.Ident("Cfg"), ")) func(func(cli ", service.GoName, "Client)) error {")
	g.P("client := ", grpccPackage.Ident("GetClient"), "(srv, opts...)")
	g.P("return func(fn func(cli ", service.GoName, "Client)) (err error) {")
	g.P("defer ", xerrorPackage.Ident("RespErr"), "(&err)")
	g.P()
	g.P("c, err := client.Get()")
	g.P("if err!=nil{")
	g.P(`return `, xerrorPackage.Ident("WrapF"), `(err, "srv: %s", srv)`)
	g.P("}")
	g.P()
	g.P("fn(&", protoutil.UnExport(service.GoName), "Client{c})")
	g.P("return")
	g.P("}")
	g.P("}")
}

func genRpcInfo(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("func init(){")
	g.P("var mthList []", xgenPackage.Ident("GrpcRestHandler"))

	var isDefault bool
	for _, m := range service.Methods {
		g.P("mthList = append(mthList, ", xgenPackage.Ident("GrpcRestHandler"), "{")
		g.P("Input:        &", g.QualifiedGoIdent(m.Input.GoIdent), "{},")
		g.P("Output:        &", g.QualifiedGoIdent(m.Output.GoIdent), "{},")
		g.P(fmt.Sprintf(`Service:"%s.%s",`, file.GoPackageName, service.GoName))
		g.P(fmt.Sprintf(`Name:"%s",`, m.GoName))

		var defaultUrl bool
		hr, err := protoutil.ExtractAPIOptions(m.Desc)
		if err != nil || hr == nil {
			defaultUrl = true
			isDefault = true
			hr = protoutil.DefaultAPIOptions(string(file.GoPackageName), service.GoName, m.GoName)
		}
		method, path := protoutil.ExtractHttpMethod(hr)
		g.P(fmt.Sprintf(`Method:"%s",`, method))
		g.P(fmt.Sprintf(`Path:"%s",`, path))
		g.P(fmt.Sprintf(`DefaultUrl:%v,`, defaultUrl))
		g.P("ClientStream:", m.Desc.IsStreamingClient(), ",")
		g.P("ServerStream:", m.Desc.IsStreamingServer(), ",")
		g.P("})")
	}
	g.P(xgenPackage.Ident("Add"), "(", reflectPackage.Ident("ValueOf"), "(Register", service.GoName, "Server),mthList)")
	if !isDefault {
		g.P(xgenPackage.Ident("Add"), "(", reflectPackage.Ident("ValueOf"), "(Register", service.GoName, "HandlerServer),nil)")
	}
	g.P("}")
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

//		func(fd *gen.FileDescriptor) string {
//			return `
//{% for ss in fd.GetService() %}
//	func Register{{ss.Srv}}RestServer(app fiber.Router, server {{ss.Srv}}Server) {
//		xerror.Assert(app == nil || server == nil, "app is nil or server is nil")
//
//		{% for m in ss.GetMethod() %}
//			{%- if !m.CS && !m.SS %}
//			// restful
//			app.Add("{{m.HttpMethod}}","{{m.HttpPath}}", func(ctx *fiber.Ctx) error {
//				var req = new({{goType(m.GetInputType())}})
//				{%- if m.HttpMethod=="GET" %}
//					data := make(map[string][]string)
//					ctx.Context().QueryArgs().VisitAll(func(key []byte, val []byte) {
//						k := utils.UnsafeString(key)
//						v := utils.UnsafeString(val)
//						if strings.Contains(v, ",") && gutil.EqualFieldType(req, reflect.Slice, k) {
//							values := strings.Split(v, ",")
//							for i := 0; i < len(values); i++ {
//								data[k] = append(data[k], values[i])
//							}
//						} else {
//							data[k] = append(data[k], v)
//						}
//					})
//					xerror.Panic(gutil.MapFormByTag(req, data, "json"))
//					var resp,err=server.{{m.GetName()}}(ctx.UserContext(),req)
//					if err!=nil{
//						return xerror.Wrap(err)
//					}
//
//					return xerror.Wrap(ctx.JSON(resp))
//				{%- else %}
//					if err := ctx.BodyParser(req); err != nil {
//						return xerror.Wrap(err)
//					}
//
//					var resp,err=server.{{m.GetName()}}(ctx.UserContext(),req)
//					if err!=nil{
//						return xerror.Wrap(err)
//					}
//
//					return xerror.Wrap(ctx.JSON(resp))
//				{%- endif %}
//			})
//			{%- else %}
//
//			// websockets
//			app.Get("{{m.HttpPath}}",fb.NewWs(func(ctx *fiber.Ctx,c *fb.Conn) {
//				{%- if m.SS && !m.CS %}
//					var req = new({{goType(m.GetInputType())}})
//					data := make(map[string][]string)
//					ctx.Context().QueryArgs().VisitAll(func(key []byte, val []byte) {
//						k := utils.UnsafeString(key)
//						v := utils.UnsafeString(val)
//						if strings.Contains(v, ",") && gutil.EqualFieldType(req, reflect.Slice, k) {
//							values := strings.Split(v, ",")
//							for i := 0; i < len(values); i++ {
//								data[k] = append(data[k], values[i])
//							}
//						} else {
//							data[k] = append(data[k], v)
//						}
//					})
//
//					xerror.Panic(gutil.MapFormByTag(req, data, "json"))
//					xerror.Panic(server.{{m.GetName()}}(req,&{{unExport(ss.Srv)}}{{m.GetName()}}Server{fb.NewWsStream(ctx,c)}))
//				{%- else %}
//					xerror.Panic(server.{{m.GetName()}}(&{{unExport(ss.Srv)}}{{m.GetName()}}Server{fb.NewWsStream(ctx,c)}))
//				{%- endif %}
//			}))
//			{%- endif %}
//		{% endfor %}
//	}
//{% endfor %}
//`
//		},
