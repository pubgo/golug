package internal

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/pubgo/lava/pkg/proto/cloudjobpb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

const jobPkg = "github.com/pubgo/lava/component/cloudjobs"
const jobTypesPkg = "github.com/pubgo/lava/pkg/proto/cloudjobpb"

type eventInfo struct {
	srv *protogen.Service
	mth *protogen.Method
}

// GenerateFile generates a .errors.pb.go file containing service definitions.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".cloudjobs.pb.go"
	genFile := jen.NewFile(string(file.GoPackageName))
	genFile.HeaderComment("Code generated by protoc-gen-cloudjobs. DO NOT EDIT.")
	genFile.HeaderComment("versions:")
	genFile.HeaderComment(fmt.Sprintf("  - protoc-gen-cloudjobs %s", version))
	genFile.HeaderComment(fmt.Sprintf("  - protoc               %s", protocVersion(gen)))
	if file.Proto.GetOptions().GetDeprecated() {
		genFile.HeaderComment(fmt.Sprintf("%s is a deprecated file.", file.Desc.Path()))
	} else {
		genFile.HeaderComment(fmt.Sprintf("source: %s", file.Desc.Path()))
	}

	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.Skip()

	if len(file.Services) == 0 {
		return g
	}

	var events = make(map[string]map[string]*eventInfo)
	for _, srv := range file.Services {
		jobName, ok := proto.GetExtension(srv.Desc.Options(), cloudjobpb.E_JobName).(string)
		if !ok || jobName == "" {
			continue
		}

		if events[jobName] == nil {
			events[jobName] = map[string]*eventInfo{}
		}

		for _, m := range srv.Methods {
			jobSubjectName, ok := proto.GetExtension(m.Desc.Options(), cloudjobpb.E_SubjectName).(string)
			if !ok || jobSubjectName == "" {
				continue
			}

			if events[jobName][jobSubjectName] != nil {
				gen.Error(fmt.Errorf("cloud job:%s subject:%s exists", jobName, jobSubjectName))
				return g
			}

			events[jobName][jobSubjectName] = &eventInfo{srv: srv, mth: m}
		}
	}

	if len(events) == 0 {
		return g
	}

	for jobName, subjects := range events {
		if len(subjects) == 0 {
			continue
		}
		g.Unskip()

		srvInfo := getSrv(subjects)

		jobKeyPrefix := strings.ReplaceAll(srvInfo.GoName, "InnerService", "")
		jobKeyPrefix = strings.ReplaceAll(jobKeyPrefix, "Inner", "") + "Service"
		jobKeyName := fmt.Sprintf("%sJobKey", jobKeyPrefix)
		genFile.Const().
			Id(jobKeyName).
			Op("=").
			Lit(jobName)
		for subName, info := range subjects {
			var keyName = fmt.Sprintf("%s%sKey", jobKeyPrefix, info.mth.GoName)
			genFile.Commentf("%s %s/%s", keyName, info.srv.GoName, info.mth.GoName)
			genFile.Commentf(strings.TrimSpace(info.mth.Comments.Leading.String()))
			genFile.Const().
				Id(keyName).
				Op("=").
				Lit(subName)
		}

		for _, info := range subjects {
			var keyName = fmt.Sprintf("%s%sKey", jobKeyPrefix, info.mth.GoName)
			genFile.Var().Id("_").Op("=").Qual(jobPkg, "RegisterSubject").
				Call(jen.Id(keyName), jen.New(jen.Id(info.mth.Input.GoIdent.GoName))).Line()

			genFile.
				Func().
				Id(fmt.Sprintf("Register%s%sCloudJob", jobKeyPrefix, info.mth.GoName)).
				Params(
					jen.Id("jobCli").Op("*").Qual(jobPkg, "Client"),
					jen.Id("handler").Func().Params(
						jen.Id("ctx").Op("*").Qual(jobPkg, "Context"),
						jen.Id("req").Op("*").Id(info.mth.Input.GoIdent.GoName),
					).Error(),
					jen.Id("opts").Op("...").Op("*").Qual(jobTypesPkg, "RegisterJobOptions"),
				).
				Block(jen.Qual(jobPkg, "RegisterJobHandler").Call(
					jen.Id("jobCli"),
					jen.Id(jobKeyName),
					jen.Id(keyName),
					jen.Id("handler"),
					jen.Id("opts").Op("..."),
				))
			genFile.Line()

			var prefix = fmt.Sprintf("Push%s", jobKeyPrefix)
			var mthName = fmt.Sprintf("%sCloudJob", info.mth.GoName)
			mthName = handlerPushEventName(mthName, prefix)
			genFile.
				Func().
				Id(mthName).
				Params(
					jen.Id("jobCli").Op("*").Qual(jobPkg, "Client"),
					jen.Id("ctx").Qual("context", "Context"),
					jen.Id("req").Op("*").Id(info.mth.Input.GoIdent.GoName),
					jen.Id("opts").Op("...").Op("*").Qual(jobTypesPkg, "PushEventOptions"),
				).Error().
				Block(jen.Return().Id("jobCli").Dot("Publish").Call(
					jen.Id("ctx"),
					jen.Id(keyName),
					jen.Id("req"),
					jen.Id("opts").Op("..."),
				))
		}
	}

	g.P(genFile.GoString())
	return g
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func handlerPushEventName(name string, prefix string) string {
	if strings.HasPrefix(name, prefix) {
		return name
	}
	return fmt.Sprintf("%s%s", prefix, name)
}

func getSrv(data map[string]*eventInfo) *protogen.Service {
	for _, srv := range data {
		return srv.srv
	}
	return nil
}
