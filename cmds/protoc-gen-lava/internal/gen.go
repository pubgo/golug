package internal

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/pubgo/funk/assert"
	"github.com/pubgo/lava/pkg/proto/lavapbv1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

const protoJsonNamePkg = "google.golang.org/protobuf/encoding/protojson"
const assertNamePkg = "github.com/pubgo/funk/assert"
const lavapbv1Pkg = "github.com/pubgo/lava/pkg/proto/lavapbv1"

type rpcMetaInfo struct {
	srv  *protogen.Service
	mth  *protogen.Method
	meta *lavapbv1.RpcMeta
}

// GenerateFile generates a .errors.pb.go file containing service definitions.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) (g *protogen.GeneratedFile) {
	filename := file.GeneratedFilenamePrefix + ".lava.pb.go"
	genFile := jen.NewFile(string(file.GoPackageName))
	genFile.HeaderComment("Code generated by protoc-gen-lava. DO NOT EDIT.")
	genFile.HeaderComment("versions:")
	genFile.HeaderComment(fmt.Sprintf("  - protoc-gen-lava %s", version))
	genFile.HeaderComment(fmt.Sprintf("  - protoc          %s", protocVersion(gen)))
	if file.Proto.GetOptions().GetDeprecated() {
		genFile.HeaderComment(fmt.Sprintf("%s is a deprecated file.", file.Desc.Path()))
	} else {
		genFile.HeaderComment(fmt.Sprintf("source: %s", file.Desc.Path()))
	}

	g = gen.NewGeneratedFile(filename, file.GoImportPath)
	g.Skip()

	if len(file.Services) == 0 {
		return g
	}

	var rpcMetas = make(map[string]*rpcMetaInfo)
	for _, srv := range file.Services {
		for _, m := range srv.Methods {
			rpcMeta, ok := proto.GetExtension(m.Desc.Options(), lavapbv1.E_Options).(*lavapbv1.RpcMeta)
			if !ok || rpcMeta == nil {
				continue
			}

			if rpcMeta.Name == "" {
				gen.Error(fmt.Errorf("rpc meta name is null, method=%s", m.GoName))
				return
			}

			if rpcMetas[rpcMeta.Name] != nil {
				gen.Error(fmt.Errorf("rpc meta name:%s already exists, method=%s", rpcMeta.Name, m.GoName))
				return
			}

			rpcMetas[rpcMeta.Name] = &rpcMetaInfo{srv: srv, mth: m, meta: rpcMeta}
		}
	}

	if len(rpcMetas) == 0 {
		return g
	}

	g.Unskip()
	for _, meta := range rpcMetas {
		srvInfo := meta.srv
		keyPrefix := strings.ReplaceAll(srvInfo.GoName, "InnerService", "")
		keyPrefix = strings.ReplaceAll(keyPrefix, "Inner", "") + "Service"
		keyName := fmt.Sprintf("%s%sAction", keyPrefix, meta.mth.GoName)

		//func() T{return T}()
		genFile.Commentf("%s %s/%s", keyName, meta.srv.GoName, meta.mth.GoName)
		genFile.Commentf(strings.TrimSpace(meta.mth.Comments.Leading.String()))
		genFile.Var().
			Id(keyName).
			Op("=").
			Func().Params().Qual(lavapbv1Pkg, "RpcMeta").
			BlockFunc(
				func(group *jen.Group) {
					group.Var().Id("p").Qual(lavapbv1Pkg, "RpcMeta")
					group.Var().Id("data").Op("=").Id(fmt.Sprintf("`%s`", assert.Exit1(protojson.Marshal(meta.meta))))
					group.Qual(assertNamePkg, "Exit").Call(
						jen.Qual(protoJsonNamePkg, "Unmarshal").Call(
							jen.Op("[]").Byte().Call(jen.Id("data")),
							jen.Id("&p"),
						),
					)
					group.Return(jen.Id("p"))
				},
			).Call()

	}

	g.P(genFile.GoString())
	return g
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}
