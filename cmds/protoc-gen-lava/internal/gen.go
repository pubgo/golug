package internal

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/pubgo/lava/core/rpcmeta"
	"github.com/pubgo/lava/pkg/proto/lavapbv1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

var rpcMetaPkg = reflect.TypeOf(rpcmeta.RpcMeta{}).PkgPath()

type rpcMetaInfo struct {
	srv  *protogen.Service
	mth  *protogen.Method
	meta *lavapbv1.RpcMeta
}

// GenerateFile generates a .errors.pb.go file containing service definitions.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) (g *protogen.GeneratedFile) {
	filename := file.GeneratedFilenamePrefix + ".lava.pb.go"
	genFile := jen.NewFile(string(file.GoPackageName))
	genFile.HeaderComment("Code generated by protoc-gen-lava. DO NOT EDIT.")
	genFile.HeaderComment("versions:")
	genFile.HeaderComment(fmt.Sprintf("  - protoc-gen-lava %s", Version))
	genFile.HeaderComment(fmt.Sprintf("  - protoc          %s", protocVersion(gen)))
	if file.Proto.GetOptions().GetDeprecated() {
		genFile.HeaderComment(fmt.Sprintf("%s is a deprecated file.", file.Desc.Path()))
	} else {
		genFile.HeaderComment(fmt.Sprintf("source: %s", file.Desc.Path()))
	}

	g = gen.NewGeneratedFile(filename, file.GoImportPath)
	g.Skip()

	if len(file.Services) == 0 {
		return g
	}

	var rpcMetas = make(map[string]*rpcMetaInfo)
	for _, srv := range file.Services {
		for _, m := range srv.Methods {
			rpcMeta, ok := proto.GetExtension(m.Desc.Options(), lavapbv1.E_Options).(*lavapbv1.RpcMeta)
			if !ok || rpcMeta == nil {
				continue
			}

			if rpcMeta.Name == "" {
				gen.Error(fmt.Errorf("rpc meta name is null, method=%s", m.GoName))
				return
			}

			if rpcMetas[rpcMeta.Name] != nil {
				gen.Error(fmt.Errorf("rpc meta name:%s already exists, method=%s", rpcMeta.Name, m.GoName))
				return
			}

			rpcMetas[rpcMeta.Name] = &rpcMetaInfo{srv: srv, mth: m, meta: rpcMeta}
		}
	}

	if len(rpcMetas) == 0 {
		return g
	}

	g.Unskip()
	for _, meta := range rpcMetas {
		srvInfo := meta.srv
		keyPrefix := strings.ReplaceAll(srvInfo.GoName, "InnerService", "")
		keyPrefix = strings.ReplaceAll(keyPrefix, "Inner", "") + "Service"

		genFile.Var().Op("_").Op("=").Qual(rpcMetaPkg, "Register").Call(
			jen.Op("&").Qual(rpcMetaPkg, "RpcMeta").Values(
				jen.Dict{
					jen.Id("Input"):  jen.New(getPkg(file, meta.mth.Input.GoIdent)),
					jen.Id("Output"): jen.New(getPkg(file, meta.mth.Output.GoIdent)),
					jen.Id("Name"):   jen.Lit(meta.meta.Name),
					jen.Id("Method"): jen.Lit(fmt.Sprintf("%s/%s", meta.srv.Desc.FullName(), meta.mth.GoName)),
					jen.Id("Tags"): jen.Map(jen.String()).String().Values(
						jen.DictFunc(func(dict jen.Dict) {
							for k, v := range meta.meta.Tags {
								dict[jen.Lit(k)] = jen.Lit(v)
							}
						}),
					),
				},
			))
	}

	g.P(genFile.GoString())
	return g
}

func getPkg(file *protogen.File, goIdent protogen.GoIdent) *jen.Statement {
	var pkgName = ""
	if file.GoImportPath != goIdent.GoImportPath {
		pkgName = string(goIdent.GoImportPath)
	}

	return jen.Qual(pkgName, goIdent.GoName)
}
