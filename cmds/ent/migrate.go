package ent

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"entgo.io/ent/dialect"
	entsql "entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/schema"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/pubgo/funk/assert"
	"github.com/pubgo/funk/config"
	"github.com/pubgo/funk/errors"
	"github.com/pubgo/funk/generic"
	"github.com/pubgo/funk/log"
	"github.com/pubgo/funk/stack"
	"github.com/pubgo/funk/try"
	"github.com/pubgo/funk/version"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
	"github.com/urfave/cli/v3"
)

type MigrationWrap struct {
	*Migration
	Executed bool
}

// Migration represents a database migration
type Migration struct {
	Name string

	Description string

	SchemaSqlFile string

	// DataMigrate is a function that will br executed while running this migration.
	DataMigrate MigrateFunc

	// DataRollback will be executed on rollback. Can be nil.
	DataRollback RollbackFunc
}

// GoMigrate represents a collection of all migrations of a database schema.
type GoMigrate struct {
	db         *entsql.Driver
	config     *Config
	migrations []*Migration
	tables     []*schema.Table
}

// New returns a new GoMigrate.
func New(db *entsql.Driver, cfg *Config, migrations []*Migration, tables []*schema.Table) *GoMigrate {
	cfg = config.MergeR(generic.Ptr(DefaultConfig), cfg).Unwrap()
	return &GoMigrate{
		db:         db,
		config:     cfg,
		migrations: migrations,
		tables:     tables,
	}
}

func (g *GoMigrate) Close() error {
	return nil
}

func (g *GoMigrate) Create(tables []*schema.Table) error {
	drv := assert.Must1(entsql.Open(dialect.Postgres, exec("15")))
	var buf bytes.Buffer
	buf.WriteString("-- DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.\n")
	buf.WriteString("-- DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.\n")
	buf.WriteString("-- DO NOT EDIT, THIS FILE IS GENERATED BY ENTORMIGRATE.\n")
	buf.WriteString(fmt.Sprintf("-- driver: %s\n", g.db.Dialect()))
	buf.WriteString("\n")
	atlas := assert.Must1(schema.NewMigrate(
		&schema.WriteDriver{Writer: &buf, Driver: drv},
		schema.WithDropColumn(true),
		schema.WithDropIndex(true),
		schema.WithForeignKeys(true),
	))
	assert.Must(atlas.Create(context.Background(), tables...))
	var filename = fmt.Sprintf("%d_%s.sql", time.Now().UnixNano(), version.Version())
	assert.Must(os.MkdirAll(g.config.MigrationPath, 0755))
	filename = filepath.Join(g.config.MigrationPath, filename)
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

func (g *GoMigrate) getMigration(name string) *Migration {
	for _, m := range g.migrations {
		if m.Name == name {
			return m
		}
	}
	return nil
}

func (g *GoMigrate) List() ([]*MigrationWrap, error) {
	nameSet, err := g.loadMigrationFromDb(context.Background())
	if err != nil {
		return nil, err
	}

	var mm []*MigrationWrap
	for _, n := range g.migrations {
		mm = append(mm, &MigrationWrap{Migration: n, Executed: nameSet.Contains(n.Name)})
	}
	return mm, nil
}

func (g *GoMigrate) Cmd() *cli.Command {
	return &cli.Command{
		Name:  "migrate",
		Usage: "migrate database schema",
		Commands: cli.Commands{
			&cli.Command{
				Name:  "migrate",
				Usage: "migrate all migrations",
				Action: func(c *cli.Context) error {
					return g.Migrate()
				},
			},
			&cli.Command{
				Name:      "migrate_to",
				Usage:     "migrate_to <name>",
				UsageText: "migrate migrate_to <name>",
				Action: func(c *cli.Context) error {
					return g.MigrateTo(c.Args().First())
				},
			},
			&cli.Command{
				Name:  "rollback",
				Usage: "rollback last migration",
				Action: func(c *cli.Context) error {
					return g.RollbackLast()
				},
			},
			&cli.Command{
				Name:  "rollback_to",
				Usage: "rollback_to <name>",
				Action: func(c *cli.Context) error {
					return g.RollbackTo(c.Args().First())
				},
			},

			&cli.Command{
				Name:  "create",
				Usage: "create migration",
				Action: func(c *cli.Context) error {
					return g.Create(g.tables)
				},
			},
			&cli.Command{
				Name:  "list",
				Usage: "list all migrations",
				Action: func(c *cli.Context) error {
					for _, m := range assert.Must1(g.List()) {
						fmt.Println(m.Name, m.Executed, m.Description)
					}
					return nil
				},
			},
		},
	}
}

// Migrate executes all migrations that did not run yet.
func (g *GoMigrate) Migrate() error {
	mm, err := g.List()
	if err != nil {
		return err
	}

	for _, m := range mm {
		if m.Executed {
			continue
		}

		err = g.insertMigration(context.Background(), m.Migration)
		if err != nil {
			return err
		}
	}
	return nil
}

func (g *GoMigrate) MigrateTo(name string) error {
	m := g.getMigration(name)
	if m == nil {
		return fmt.Errorf("ormigrate: Tried to migrate to an ID that doesn't exist")
	}

	return g.insertMigration(context.Background(), m)
}

// RollbackLast undo the last migration
func (g *GoMigrate) RollbackLast() error {
	mm, err := g.List()
	if err != nil {
		return err
	}

	for i := len(mm) - 1; i >= 0; i-- {
		if mm[i].Executed {
			continue
		}

		return g.rollbackMigration(context.Background(), mm[i].Migration)
	}

	return nil
}

// RollbackTo undoes migrations up to the given migration that matches the `migrationID`.
// Migration with the matching `name` is not rolled back.
func (g *GoMigrate) RollbackTo(name string) error {
	m := g.getMigration(name)
	if m == nil {
		return fmt.Errorf("ormigrate: Could not find last run migration")
	}
	return g.rollbackMigration(context.Background(), m)
}

// createTableIfNotExists creates a table if it does not already exist in the database.
func (g *GoMigrate) createTableIfNotExists(ctx context.Context) error {
	var sql = fmt.Sprintf(sqlTmpl.CreateTable, g.config.TableName, g.config.ColumnName, g.config.ColumnSize)
	_, err := g.db.ExecContext(ctx, sql)
	return err
}

func (g *GoMigrate) insertMigration(ctx context.Context, m *Migration) error {
	sql := fmt.Sprintf(sqlTmpl.CreateMigration, g.config.TableName, g.config.ColumnName)
	tx := g.config.GenTx(g.db)
	return withTx(ctx, tx, func(tx Tx) error {
		_, err := tx.ExecContext(ctx, m.SchemaSqlFile)
		if err != nil {
			return err
		}

		_, err = tx.ExecContext(ctx, sql, m.Name)
		if err != nil {
			return err
		}

		if m.DataMigrate == nil {
			return nil
		}

		return m.DataMigrate(ctx, tx)
	})
}

func (g *GoMigrate) rollbackMigration(ctx context.Context, m *Migration) error {
	sql := fmt.Sprintf(sqlTmpl.DropMigration, g.config.TableName, g.config.ColumnName)
	tx := g.config.GenTx(g.db)

	return withTx(ctx, tx, func(tx Tx) error {
		_, err := tx.ExecContext(ctx, sql, m.Name)
		if err != nil {
			return err
		}

		if m.DataRollback == nil {
			return nil
		}

		return m.DataRollback(ctx, tx)
	})
}

func (g *GoMigrate) loadMigrationFromDb(ctx context.Context) (mapset.Set[string], error) {
	err := g.createTableIfNotExists(ctx)
	if err != nil {
		return nil, errors.WrapCaller(err)
	}

	sql := fmt.Sprintf(sqlTmpl.ListMigration, g.config.ColumnName, g.config.TableName)
	rows, err := g.db.QueryContext(ctx, sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var ss = mapset.NewSet[string]()
	for rows.Next() {
		var migrationID string
		if err := rows.Scan(&migrationID); err != nil {
			return nil, err
		}
		ss.Add(migrationID)
	}
	return ss, nil
}

func withTx(ctx context.Context, tx Tx, callback func(tx Tx) error) (gErr error) {
	err := try.Try(func() error { return callback(tx) })
	if err != nil {
		log.Err(err, ctx).Str("handler", stack.CallerWithFunc(callback).String()).Msg("failed to do tx handler")
		if err1 := tx.Rollback(); err1 != nil {
			return errors.Wrap(err1, "failed to rollback transaction")
		}
		return errors.Wrap(err, "failed to exec transaction")
	}

	return errors.Wrap(tx.Commit(), "failed to committing transaction")
}

func exec(ver string) string {
	if ver == "" {
		ver = defaultPostgresVersion
	}

	ctx := context.Background()
	waitForLogs := wait.
		ForLog("database system is ready to accept connections").
		WithOccurrence(2).
		WithStartupTimeout(5 * time.Second)

	ctr := assert.Must1(postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:"+ver),
		testcontainers.WithWaitStrategy(waitForLogs),
	))

	return assert.Must1(ctr.ConnectionString(ctx, "sslmode=disable"))
}
